# Radix-16 Modified Booth 64-bit Multiplier – SystemVerilog RTL Design

A 64-bit combinational multiplier implemented in **SystemVerilog HDL** and synthesised on **Kintex-7 KCU105** using Vivado 2023. 

*Note that This project is part of my graduation project which was to design a RISC-V processor capable of running Linux-based OS.*

# Preliminaries
One of the challenges in VLSI design is to design efficient and fast multipliers, which are the core components of many arithmetic operations.
In general, an N × N multiplier multiplies two N-bit numbers and produces a 2N-bit result.
Signed and unsigned multiplication differ. For example, consider 0xFE × 0xFD. If these 8-bit numbers are interpreted as signed integers, they represent −2 and −3, so the 16-bit product is 0x0006. If these numbers are interpreted as unsigned integers, the 16-bit product is 0xFB06. Notice that, in either case, the least significant byte is 0x06.
M × N-bit multiplication P = Y × X can be viewed as forming N partial products of M bits each, and then summing the appropriately shifted partial products to produce an M + N-bit result P.


# Proposed Algorithm

To improve the speed performance of multiplication, the number of partial products have been reduced by using **Radix-16 Booth Algorithm** and for reducing the delay of summation of partial products **Wallace Tree** Structure has been used. These partial products are summed using a compressor in the structure of Wallace Tree. We used eight 4-2 compressors arranged in 4 levels. CLA has been used for final results where CLA indicates carry look ahead adder that
ahead carry of compressor.

### Algorithm steps
1. Sign-extend the multiplicand X to be N+1.
2. Sign-extend the multiplier to be N+4 and append a zero at LSB the multiplier.
3. Divide the multiplier into groups each of overlapped 5-bits (r+1) as shown in figure 2.
4. Use each group to generate a partial product.
5. Compress each 4 partial products using a 4-2 compressor.
Use CLA to obtain the final result.
![Steps](/images/steps.png)



Let’s discuss an example of a **radix-4** booth encoder for **6 x 6-bit signed multiplication**:
A radix-4 multiplier produces N/2 partial products. Each partial product is 0, Y, 2Y, or 3Y, depending on a pair of bits of X. Computing 2Y is a simple shift, but 3Y is a hard multiple requiring a slow carry propagate addition of Y + 2Y before partial product generation begins.
Modified Booth encoding allows higher radix parallel operation without generating the hard 3Y multiple by instead using negative partial products. Observe that 3Y = 4Y – Y and 2Y = 4Y – 2Y. 
Table below shows how the partial products are selected, based on bits of the multiplier. Negative partial products are generated by taking the two’s complement of the multiplicand (possibly left-shifted by one column for –2Y).
![Alt Text](/images/PP4.png)

##### Example 1: 
![Example 1](/images/ex1.png)
##### Example 2
![Example 2](/images/ex2.png)
##### Example 3
![Example 3](/images/ex3.png)
##### Example 4
![Example 4](/images/ex4.png)

### Radix-16 booth encoder for 64 x 64-bit multiplication.
In the proposed modified Booth Algorithm, we perform signed multiplication. Multiplier X and Multiplicand Y are appended with a sign bit to specify whether it is a signed or unsigned operand. 
For multiplier X, a zero is appended at LSB and sign-extended by 3 bits at MSB then it has been divided into groups of overlapped 5-bits as shown in the figure below.
![alt text](/images/Multiplier.png)

Each group of 5-bits have been operationed according to modified Booth Algorithm for generation of partial products ±0, ±Y, ±2Y, ±3Y, ±4Y, ±5Y, ±6Y, ±7Y, ±8Y as shown in the table below.
![alt text](/images/radix16.png)
- The multiples 2Y, 4Y and 8Y can be obtained by simple shifting from Y. 
- The multiples 3Y, 5Y, 6Y and 7Y are the complex multiples of Y. Because 6Y can be obtained by shifting from 3Y. 
- 3Y, 5Y and 7Y are the only complex multiples that need to be sub-generated by adder.

Number of partial products for N x N-bit signed multiplication is:
 ⌈N/r⌉ = ⌈(64 + 1) / log₂16⌉ = 17 PP.

To perform 64-bit multiplication, each PP is appended with zeros at LSB and sign-extended to be of length 2xN = 128.

To perform unsigned multiplication, we append a zero at MSB of the operand to be unsigned and then perform signed multiplication on 65-bit data width as shown in the following piece of code:
<pre> ```systemverilog def 
     case (i_mul_in_control)
          MUL:
            begin
              o_mul_in_multiplicand = {i_mul_in_srcA[XLEN-1], i_mul_in_srcA};
              o_mul_in_multiplier = {i_mul_in_srcB[XLEN-1], i_mul_in_srcB};
            end
          MULH:
            begin
              o_mul_in_multiplicand = {i_mul_in_srcA[XLEN-1], i_mul_in_srcA};
              o_mul_in_multiplier = {i_mul_in_srcB[XLEN-1], i_mul_in_srcB};
            end
          MULHSU:
            begin
              o_mul_in_multiplicand = {i_mul_in_srcA[XLEN-1], i_mul_in_srcA};
              o_mul_in_multiplier = {1'b0, i_mul_in_srcB};
            end
          MULHU:
            begin
              o_mul_in_multiplicand = {1'b0, i_mul_in_srcA};
              o_mul_in_multiplier = {1'b0, i_mul_in_srcB};
            end
          default:
            begin
              o_mul_in_multiplicand = {i_mul_in_srcA[XLEN-1], i_mul_in_srcA};
              o_mul_in_multiplier = {i_mul_in_srcB[XLEN-1], i_mul_in_srcB};
            end
    endcase 
``` </pre>

### 4-Levels Wallace tree using 4-2 Compressor
To accelerate the speed of the whole adder array, the partial products need to be compressed. 4-2 compressor is the most frequently used component during the compressing of partial products. Its structure is shown in figure below.
<img src="/images/Compressor.png" width="300"/>

There are 4 partial product input signals to the 4-2 compressor. They are In1:In4, Cin is the carry input of the adjacent compressor; sum is pseudo-sum; Carry and Cout are carry output, they have the same weights. The independence of input carry and output carry can insure the partial product add separately at the same time.
The four inputs In1, In2, In3, and In4, and the output sum have the same weight. The output carry is weighted one binary bit order higher.
By Radix-16 Booth encoding the 64 × 64-bit Parallel multiplier, 17 partial products are obtained. After the compress of the 4-2 compressor, the compressed tree is shown in figure below.
CLA has been used for final results where CLA indicates carry look ahead adder that ahead carry of compressor.
![alt text](/images/tree.png)

---
## Project Structure

```plaintext
RADIX-16-MODIFIED-BOOTH-64-BIT-MULTIPLIER/
│
├── src/                                      # SystemVerilog RTL design files
│   ├── riscv_core_4_2_compressor.sv          # 4-2 Compressor
│   ├── riscv_core_4_2_compressor1bit.sv      # 4-2 Compressor 1-bit
│   ├── riscv_core_16booth_encoder.sv         # Radix-16 booth encoder
│   ├── riscv_core_cla_4bit.sv                # Carry Look Ahead Adder 4-bit
│   ├── riscv_core_cla_128bit.sv              # Carry Look Ahead Adder 128-bit
│   ├── riscv_core_full_adder.sv              # 1-bit Full Adder
│   ├── riscv_core_gp_gen.sv                  # Carry-Generated and Carry-Propagated
│   ├── riscv_core_mul_ext.sv                 # Extension to 2xN
│   ├── riscv_core_mul_in.sv                  # Prepare the operands according to the operation (signed/unsigned)
│   ├── riscv_core_mul_out.sv                 # Prepare the result according to the operation (signed/unsigned)
│   └── riscv_core_mul.sv                     # Top module
│
├── Testbench/                                # Testbench and simulation files
│   └── riscv_core_mul_tb.sv                  # Testbench for the riscv_core_mul module
│
├── FPGA Imp/                                 # Snaps from FPGA Implemenation using Vivado
│
└── README.md                                 # Project documentation 
```
---











